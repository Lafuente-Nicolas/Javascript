##  langage OrientÃ© Objet

def : La programmation orientÃ©e objet, câ€™est une maniÃ¨re dâ€™Ã©crire du code en utilisant des objets qui regroupent des informations et des actions.

JavaScript est un langage orientÃ© vers le fonctionnel. Cela nous donne beaucoup de libertÃ©. Une fonction peut Ãªtre crÃ©Ã©e dynamiquement, passÃ©e en argument Ã  une autre fonction et appelÃ©e ultÃ©rieurement Ã  partir dâ€™un code totalement diffÃ©rent. 

Quand on dit que JavaScript est orientÃ© vers le fonctionnel, cela veut dire quâ€™il permet de manipuler facilement les fonctions comme des donnÃ©es, de les transmettre, les composer, les retourner, et cela rend le code plus flexible, modulaire et rÃ©utilisable.

## Abstraction

mettre un # si on veut que se soir privÃ©

L'abstraction dans le domaine de la programmation informatique permet de rÃ©duire la complexitÃ© et d'obtenir une conception et une implÃ©mentation plus efficaces dans les systÃ¨mes logiciels complexes. Elle dissimule les complexitÃ©s techniques des systÃ¨mes derriÃ¨re des API plus simples Ã  manipuler.

__Avantages de l'abstraction de donnÃ©es__

- Ã‰viter d'Ã©crire du code de bas niveau.
- Ã‰viter la duplication de code et augmenter la rÃ©utilisabilitÃ©.
- Pouvoir modifier l'implÃ©mentation interne d'une classe objet, sans affecter les personnes ou codes qui l'utilisent.
-  AmÃ©liorer la sÃ©curitÃ© d'une application ou d'un programme en exposant uniquement les dÃ©tails importants pour l'usage.
```js
class MachineCafe {
  servirCafe() {
    this.#chaufferEau();
    this.#moudreCafe();
    this.#remplirTasse();
    console.log("â˜• CafÃ© prÃªt !");
  }

  // MÃ©thodes privÃ©es
  #chaufferEau() {
    console.log("ğŸ”¥ Eau chauffÃ©e");
  }

  #moudreCafe() {
    console.log("ğŸ«˜ CafÃ© moulu");
  }

  #remplirTasse() {
    console.log("ğŸ¥¤ Tasse remplie");
  }
}

// CrÃ©ation d'une machine Ã  cafÃ©
const machine = new MachineCafe();

// Appel de la mÃ©thode publique
machine.servirCafe();

// Essaye Ã§a aussi pour voir l'erreur d'accÃ¨s Ã  une mÃ©thode privÃ©e :
try {
  machine.#chaufferEau(); // âŒ Erreur ! MÃ©thode privÃ©e
} catch (e) {
  console.error("âŒ Erreur d'accÃ¨s privÃ© :", e.message);
}

```

## une instance 

Une instance, câ€™est un objet crÃ©Ã© Ã  partir dâ€™un modÃ¨le (une classe).

     Classe = plan de construction
     Instance = maison construite Ã  partir de ce plan

 Exemple simple en franÃ§ais :

Si tu as une classe appelÃ©e Chien, tu peux crÃ©er plusieurs chiens diffÃ©rents.

Chaque chien que tu crÃ©es est une instance.

Exemple :
```js
class Chien {
  constructor(nom, race) {
    this.nom = nom;
    this.race = race;
  }

  aboyer() {
    console.log(this.nom + " aboie : Wouf !");
  }
}

// ğŸ”¸ CrÃ©ation de deux instances avec new :
const milou = new Chien("Milou", "Fox-Terrier");
const rex = new Chien("Rex", "Berger Allemand");

// ğŸ”¸ Utilisation des mÃ©thodes :
milou.aboyer(); // Affiche : Milou aboie : Wouf !
rex.aboyer();   // Affiche : Rex aboie : Wouf !
```
## Les classes

 Une classe, câ€™est un modÃ¨le ou plan de fabrication pour crÃ©er des objets.

Câ€™est comme une recette de cuisine :

- La recette donne les ingrÃ©dients et les Ã©tapes

- Mais tant que tu ne lâ€™as pas utilisÃ©e, le gÃ¢teau nâ€™existe pas encore

- Quand tu suis la recette â†’ tu obtiens un gÃ¢teau rÃ©el â†’ câ€™est lâ€™instance
```js
class Voiture {
  constructor(marque, couleur) {
    this.marque = marque;
    this.couleur = couleur;
  }

  demarrer() {
    console.log(this.marque + " dÃ©marre ğŸš—");
  }
}
```
Explication :

    Voiture est une classe

    Elle a des propriÃ©tÃ©s : marque et couleur

    Elle a une mÃ©thode : demarrer()


## diffÃ©rences entre classes concrÃ¨tes et abstraites 
Une classe abstraite sert Ã  dÃ©finir des rÃ¨gles et des mÃ©thodes Ã  implÃ©menter par ses sous-classes, tandis quâ€™une classe concrÃ¨te est une classe complÃ¨te que lâ€™on peut utiliser directement pour crÃ©er des objets.

```js
// Classe abstraite (on ne peut pas faire "new" dessus)
class Animal {
  faireDuBruit() {
    throw "Ã€ dÃ©finir dans la sous-classe !";
  }
}

// Classe concrÃ¨te (on peut crÃ©er une instance)
class Chien extends Animal {
  faireDuBruit() {
    console.log("Wouf !");
  }
}

const monChien = new Chien();
monChien.faireDuBruit(); // Affiche : Wouf !
```
## le constructeur (constructor)

Le constructeur est une fonction spÃ©ciale qui donne ses premiÃ¨res valeurs Ã  un objet quand il est crÃ©Ã©.

Le constructor est prÃªt dans la classe, mais il ne sert Ã  rien tant que tu ne fais pas new pour crÃ©er un objet.

- constructor(...) est automatiquement appelÃ© quand tu fais new.
- Il permet de donner des valeurs de dÃ©part Ã  ton objet.

##  Attributs / PropriÃ©tÃ©s et MÃ©thodes
```js
class Voiture {
  constructor(marque, couleur) {
    this.marque = marque;     // propriÃ©tÃ©
    this.couleur = couleur;   // propriÃ©tÃ©
  }

  klaxonner() {               // mÃ©thode
    console.log("Tuut tuut !");
  }
}
```
```js
const maVoiture = new Voiture("Peugeot", "rouge");

console.log(maVoiture.marque);    // â†’ Peugeot (attribut)
console.log(maVoiture.couleur);   // â†’ rouge (attribut)

maVoiture.klaxonner();            // â†’ Tuut tuut ! (mÃ©thode)
```
| Ã‰lÃ©ment  | Ce que câ€™est                  | Exemple                  |
|----------|-------------------------------|---------------------------|
| Attribut | Une donnÃ©e de lâ€™objet         | `this.marque = "Peugeot"` |
| MÃ©thode  | Une action que lâ€™objet fait   | `klaxonner()`             |

## diffÃ©rence entre les  classes et  les fonctions

Classes :
â†’ CrÃ©er des objets qui reprÃ©sentent des choses du monde rÃ©el (ex : une voiture, un utilisateur), avec leurs caractÃ©ristiques (attributs) et comportements (mÃ©thodes).
â†’ Parfait pour gÃ©rer des donnÃ©es complexes et garder le code organisÃ©.

Fonctions :
â†’ Faire des calculs, manipuler des donnÃ©es, exÃ©cuter une tÃ¢che spÃ©cifique (ex : additionner deux nombres, afficher un message).
â†’ TrÃ¨s pratiques pour des actions simples ou rÃ©pÃ©tÃ©es.

```js
// Fonction
function addition(a, b) {
  return a + b;
}

// Classe
class Voiture {
  constructor(marque) {
    this.marque = marque;
  }
  klaxonner() {
    console.log("Bip bip !");
  }
}
```
## l'utilitÃ©
ğŸ”¹ Fonctions

    Effectuer des tÃ¢ches ou calculs prÃ©cis : additionner, afficher un message, manipuler des donnÃ©es.

    RÃ©utiliser du code facilement en appelant plusieurs fois la mÃªme fonction.

    Simplifier ton code en regroupant des instructions.

    Fonctions pures (sans effets secondaires) utilisÃ©es dans la programmation fonctionnelle.

ğŸ”¹ Classes

    ModÃ©liser des objets complexes avec des propriÃ©tÃ©s (attributs) et des comportements (mÃ©thodes).

    CrÃ©er plusieurs objets similaires facilement grÃ¢ce aux instances.

    Organiser le code en regroupant donnÃ©es et fonctions dans un mÃªme Â« modÃ¨le Â».

    Encapsuler la logique interne (avec mÃ©thodes et propriÃ©tÃ©s privÃ©es).

    Favoriser la rÃ©utilisation et lâ€™extension via lâ€™hÃ©ritage (classes qui hÃ©ritent dâ€™autres classes).

## Getters / Setters

 Les getters et setters permettent de lire (get) et modifier (set) les valeurs dâ€™un objet de maniÃ¨re contrÃ´lÃ©e, sans accÃ©der directement aux propriÃ©tÃ©s internes.

```js
class Personne {
  constructor(nom) {
    this._nom = nom;  // Attribut "privÃ©" (convention)
  }

  // Getter pour lire le nom
  get nom() {
    return this._nom;
  }

  // Setter pour changer le nom
  set nom(nouveauNom) {
    this._nom = nouveauNom;
  }
}

const p = new Personne("Nico");

console.log(p.nom);  // Affiche "Nico"

p.nom = "Jean";      // Change le nom via le setter

console.log(p.nom);  // Affiche "Jean"
```
ne pas oublier le `_` sinon Ã§a peut faire une boucle infini.

## le principe d'encapsulation

Utiliser les `getters` et `setters`, câ€™est une faÃ§on trÃ¨s courante de faire de lâ€™encapsulation.

Lâ€™encapsulation, câ€™est :

- Cacher ou protÃ©ger les donnÃ©es internes dâ€™un objet pour Ã©viter quâ€™elles soient modifiÃ©es nâ€™importe comment.

on utlise `_` pour l'encapsulation 