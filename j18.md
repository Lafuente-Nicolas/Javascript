##  langage Orient√© Objet

def : La programmation orient√©e objet, c‚Äôest une mani√®re d‚Äô√©crire du code en utilisant des objets qui regroupent des informations et des actions.

JavaScript est un langage orient√© vers le fonctionnel. Cela nous donne beaucoup de libert√©. Une fonction peut √™tre cr√©√©e dynamiquement, pass√©e en argument √† une autre fonction et appel√©e ult√©rieurement √† partir d‚Äôun code totalement diff√©rent. 

Quand on dit que JavaScript est orient√© vers le fonctionnel, cela veut dire qu‚Äôil permet de manipuler facilement les fonctions comme des donn√©es, de les transmettre, les composer, les retourner, et cela rend le code plus flexible, modulaire et r√©utilisable.

## Abstraction

mettre un # si on veut que se soir priv√©

L'abstraction dans le domaine de la programmation informatique permet de r√©duire la complexit√© et d'obtenir une conception et une impl√©mentation plus efficaces dans les syst√®mes logiciels complexes. Elle dissimule les complexit√©s techniques des syst√®mes derri√®re des API plus simples √† manipuler.

__Avantages de l'abstraction de donn√©es__

- √âviter d'√©crire du code de bas niveau.
- √âviter la duplication de code et augmenter la r√©utilisabilit√©.
- Pouvoir modifier l'impl√©mentation interne d'une classe objet, sans affecter les personnes ou codes qui l'utilisent.
-  Am√©liorer la s√©curit√© d'une application ou d'un programme en exposant uniquement les d√©tails importants pour l'usage.
```js
class MachineCafe {
  servirCafe() {
    this.#chaufferEau();
    this.#moudreCafe();
    this.#remplirTasse();
    console.log("‚òï Caf√© pr√™t !");
  }

  // M√©thodes priv√©es
  #chaufferEau() {
    console.log("üî• Eau chauff√©e");
  }

  #moudreCafe() {
    console.log("ü´ò Caf√© moulu");
  }

  #remplirTasse() {
    console.log("ü•§ Tasse remplie");
  }
}

// Cr√©ation d'une machine √† caf√©
const machine = new MachineCafe();

// Appel de la m√©thode publique
machine.servirCafe();

// Essaye √ßa aussi pour voir l'erreur d'acc√®s √† une m√©thode priv√©e :
try {
  machine.#chaufferEau(); // ‚ùå Erreur ! M√©thode priv√©e
} catch (e) {
  console.error("‚ùå Erreur d'acc√®s priv√© :", e.message);
}

```

## une instance 

Une instance, c‚Äôest un objet cr√©√© √† partir d‚Äôun mod√®le (une classe).

     Classe = plan de construction
     Instance = maison construite √† partir de ce plan

 Exemple simple en fran√ßais :

Si tu as une classe appel√©e Chien, tu peux cr√©er plusieurs chiens diff√©rents.

Chaque chien que tu cr√©es est une instance.

Exemple :
```js
class Chien {
  constructor(nom, race) {
    this.nom = nom;
    this.race = race;
  }

  aboyer() {
    console.log(this.nom + " aboie : Wouf !");
  }
}

// üî∏ Cr√©ation de deux instances avec new :
const milou = new Chien("Milou", "Fox-Terrier");
const rex = new Chien("Rex", "Berger Allemand");

// üî∏ Utilisation des m√©thodes :
milou.aboyer(); // Affiche : Milou aboie : Wouf !
rex.aboyer();   // Affiche : Rex aboie : Wouf !
```
## Les classes

 Une classe, c‚Äôest un mod√®le ou plan de fabrication pour cr√©er des objets.

C‚Äôest comme une recette de cuisine :

- La recette donne les ingr√©dients et les √©tapes

- Mais tant que tu ne l‚Äôas pas utilis√©e, le g√¢teau n‚Äôexiste pas encore

- Quand tu suis la recette ‚Üí tu obtiens un g√¢teau r√©el ‚Üí c‚Äôest l‚Äôinstance
```js
class Voiture {
  constructor(marque, couleur) {
    this.marque = marque;
    this.couleur = couleur;
  }

  demarrer() {
    console.log(this.marque + " d√©marre üöó");
  }
}
```
Explication :

    Voiture est une classe

    Elle a des propri√©t√©s : marque et couleur

    Elle a une m√©thode : demarrer()


## diff√©rences entre classes concr√®tes et abstraites 
Une classe abstraite sert √† d√©finir des r√®gles et des m√©thodes √† impl√©menter par ses sous-classes, tandis qu‚Äôune classe concr√®te est une classe compl√®te que l‚Äôon peut utiliser directement pour cr√©er des objets.

```js
// Classe abstraite (on ne peut pas faire "new" dessus)
class Animal {
  faireDuBruit() {
    throw "√Ä d√©finir dans la sous-classe !";
  }
}

// Classe concr√®te (on peut cr√©er une instance)
class Chien extends Animal {
  faireDuBruit() {
    console.log("Wouf !");
  }
}

const monChien = new Chien();
monChien.faireDuBruit(); // Affiche : Wouf !
```
## le constructeur (constructor)

Le constructeur est une fonction sp√©ciale qui donne ses premi√®res valeurs √† un objet quand il est cr√©√©.

Le constructor est pr√™t dans la classe, mais il ne sert √† rien tant que tu ne fais pas new pour cr√©er un objet.

- constructor(...) est automatiquement appel√© quand tu fais new.
- Il permet de donner des valeurs de d√©part √† ton objet.

##  Attributs / Propri√©t√©s et M√©thodes
```js
class Voiture {
  constructor(marque, couleur) {
    this.marque = marque;     // propri√©t√©
    this.couleur = couleur;   // propri√©t√©
  }

  klaxonner() {               // m√©thode
    console.log("Tuut tuut !");
  }
}
```
```js
const maVoiture = new Voiture("Peugeot", "rouge");

console.log(maVoiture.marque);    // ‚Üí Peugeot (attribut)
console.log(maVoiture.couleur);   // ‚Üí rouge (attribut)

maVoiture.klaxonner();            // ‚Üí Tuut tuut ! (m√©thode)
```
| √âl√©ment  | Ce que c‚Äôest                  | Exemple                  |
|----------|-------------------------------|---------------------------|
| Attribut | Une donn√©e de l‚Äôobjet         | `this.marque = "Peugeot"` |
| M√©thode  | Une action que l‚Äôobjet fait   | `klaxonner()`             |

## diff√©rence entre les  classes et  les fonctions

Classes :
‚Üí Cr√©er des objets qui repr√©sentent des choses du monde r√©el (ex : une voiture, un utilisateur), avec leurs caract√©ristiques (attributs) et comportements (m√©thodes).
‚Üí Parfait pour g√©rer des donn√©es complexes et garder le code organis√©.

Fonctions :
‚Üí Faire des calculs, manipuler des donn√©es, ex√©cuter une t√¢che sp√©cifique (ex : additionner deux nombres, afficher un message).
‚Üí Tr√®s pratiques pour des actions simples ou r√©p√©t√©es.

```js
// Fonction
function addition(a, b) {
  return a + b;
}

// Classe
class Voiture {
  constructor(marque) {
    this.marque = marque;
  }
  klaxonner() {
    console.log("Bip bip !");
  }
}
```
## l'utilit√©
üîπ Fonctions

    Effectuer des t√¢ches ou calculs pr√©cis : additionner, afficher un message, manipuler des donn√©es.

    R√©utiliser du code facilement en appelant plusieurs fois la m√™me fonction.

    Simplifier ton code en regroupant des instructions.

    Fonctions pures (sans effets secondaires) utilis√©es dans la programmation fonctionnelle.

üîπ Classes

    Mod√©liser des objets complexes avec des propri√©t√©s (attributs) et des comportements (m√©thodes).

    Cr√©er plusieurs objets similaires facilement gr√¢ce aux instances.

    Organiser le code en regroupant donn√©es et fonctions dans un m√™me ¬´ mod√®le ¬ª.

    Encapsuler la logique interne (avec m√©thodes et propri√©t√©s priv√©es).

    Favoriser la r√©utilisation et l‚Äôextension via l‚Äôh√©ritage (classes qui h√©ritent d‚Äôautres classes).

## Getters / Setters

 Les getters et setters permettent de lire (get) et modifier (set) les valeurs d‚Äôun objet de mani√®re contr√¥l√©e, sans acc√©der directement aux propri√©t√©s internes.

```js
class Personne {
  constructor(nom) {
    this._nom = nom;  // Attribut "priv√©" (convention)
  }

  // Getter pour lire le nom
  get nom() {
    return this._nom;
  }

  // Setter pour changer le nom
  set nom(nouveauNom) {
    this._nom = nouveauNom;
  }
}

const p = new Personne("Nico");

console.log(p.nom);  // Affiche "Nico"

p.nom = "Jean";      // Change le nom via le setter

console.log(p.nom);  // Affiche "Jean"
```
ne pas oublier le `_` sinon √ßa peut faire une boucle infini.

## le principe d'encapsulation

Utiliser les `getters` et `setters`, c‚Äôest une fa√ßon tr√®s courante de faire de l‚Äôencapsulation.

L‚Äôencapsulation, c‚Äôest :

- Cacher ou prot√©ger les donn√©es internes d‚Äôun objet pour √©viter qu‚Äôelles soient modifi√©es n‚Äôimporte comment. 

on utlise `_` pour l'encapsulation priv√© et `#` pour l'encapsulation prot√©g√©.

```js
class Personne {
  // Propri√©t√© priv√©e r√©elle (encapsulation stricte)
  #nom;

  // Propri√©t√© "prot√©g√©e" par convention
  _age;

  constructor(nom, age) {
    this.#nom = nom;
    this._age = age;
  }
  ```