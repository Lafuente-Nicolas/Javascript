## l'héritage

---

##  À quoi sert l'héritage ?

L’héritage permet de :

- **Réutiliser du code** existant sans le recopier.
- **Organiser** les classes de façon logique (ex. : général → spécifique).
- **Spécialiser** une classe en ajoutant ou modifiant des comportements.

 C’est un **gain de temps**, de **lisibilité** et de **maintenabilité**.

---

##  Comment écrit-on de l’héritage en JavaScript ?

On utilise le mot-clé `extends` pour dire qu’une **classe enfant hérite** d’une **classe parent**.

```js
// Classe parent
class Animal {
  manger() {
    console.log("Je mange.");
  }
}

// Classe enfant
class Chien extends Animal {
  aboyer() {
    console.log("Wouf !");
  }
}

const medor = new Chien();
medor.manger(); // ✅ méthode héritée
medor.aboyer(); // ✅ méthode propre à Chien
```
## Dans quels cas utilise-t-on l’héritage ?

- Quand plusieurs objets partagent un comportement commun (ex. Voiture, Moto → Vehicule).

- Quand on veut factoriser du code dans une classe de base.

- Quand on a une relation "est un" :

        Un chien est un animal.

        Une voiture est un véhicule.

-  On n’utilise pas l’héritage juste pour réutiliser une méthode. Il faut qu’il y ait une relation logique.

## Relations parents ↔ enfants

### Parent → Enfant :

- Le parent transmet ses propriétés et méthodes.

- L’enfant peut les utiliser, les surcharger (modifier), ou les compléter.
```js
class Animal {
  parler() {
    console.log("Je fais un bruit.");
  }
}

class Chat extends Animal {
  parler() {
    console.log("Miaou !");
  }
}
```

### Enfant → Parent :

L’enfant peut appeler le constructeur parent avec super().
```js
class Animal {
  constructor(nom) {
    this.nom = nom;
  }
}

class Chien extends Animal {
  constructor(nom, race) {
    super(nom); // Appelle le constructeur parent
    this.race = race;
  }
}
```

## L'interface

il y a un mot-clé interface qui te permet de définir une interface officielle,

Une interface est un contrat que les classes doivent respecter.
Elle décrit ce qu’une classe doit faire, mais pas comment elle le fait.

 Elle définit les noms des méthodes qu’une classe doit posséder, sans leur contenu.
 ```js
 class Oiseau {
  voler() {
    throw new Error("Tu dois créer la méthode voler()");
  }

  chanter() {
    throw new Error("Tu dois créer la méthode chanter()");
  }
}

// Cette classe respecte les méthodes demandées
class Moineau extends Oiseau {
  voler() {
    console.log("Je vole vite !");
  }

  chanter() {
    console.log("Piou piou !");
  }
}

const m = new Moineau();
m.voler();    // ✅ "Je vole vite !"
m.chanter();  // ✅ "Piou piou !"
```