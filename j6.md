# les Objets 

En JavaScript, un objet est une structure de donn√©es permettant de stocker des collections de donn√©es et des entit√©s plus complexes. Il est compos√© de paires cl√©-valeur, o√π chaque cl√© (ou propri√©t√©) est une cha√Æne de caract√®res, et chaque valeur peut √™tre de n'importe quel type.

Les objets sont omnipr√©sents en JavaScript et constituent la base de nombreux concepts avanc√©s.

## 1. Cr√©ation d'un objet (notation litt√©rale)
```js
let utilisateur = {
  nom: "Alice",
  age: 25
};
```
‚û°Ô∏è Explication :

On cr√©e un objet utilisateur avec deux propri√©t√©s :

    nom : la valeur est "Alice"

    age : la valeur est 25

C'est une syntaxe classique : `{ cl√©1: valeur1, cl√©2: valeur2 }`

## 2. Cr√©ation avec le constructeur Object
```js
let utilisateur = new Object();
utilisateur.nom = "Alice";
utilisateur.age = 25;
```
‚û°Ô∏è Explication :

C‚Äôest une autre mani√®re de cr√©er un objet :

 - D‚Äôabord on cr√©e un objet vide avec `new Object()`

-  Ensuite on ajoute les propri√©t√©s `nom et age` en les d√©finissant avec la notation point.

C‚Äôest un peu plus long, mais c‚Äôest √©quivalent au premier exemple.

## 3. Acc√®s aux propri√©t√©s (notation point)
```js
console.log(utilisateur.nom); // "Alice"
```
‚û°Ô∏è Explication :

On utilise la notation point pour acc√©der √† une propri√©t√© de l‚Äôobjet. 

Ici, on affiche "Alice".

## 4. Acc√®s aux propri√©t√©s (notation crochets)
```js
console.log(utilisateur["nom"]); // "Alice"
```
‚û°Ô∏è Explication :

On acc√®de √† la m√™me propri√©t√© mais avec des crochets et une cha√Æne de caract√®res.

C‚Äôest utile quand :

- la propri√©t√© a un espace ou un caract√®re sp√©cial
- ou quand on utilise une variable comme cl√© (exemple juste apr√®s)

## 5. Acc√®s dynamique avec une variable
```js
let propriete = "age";
console.log(utilisateur[propriete]); // 25
```
‚û°Ô∏è Explication :

propriete contient "age", donc utilisateur[propriete] revient √† faire utilisateur["age"], ce qui donne 25.

## 6. Ajouter une propri√©t√©
```js
utilisateur.email = "alice@example.com";
```
‚û°Ô∏è Explication :

On ajoute une nouvelle propri√©t√© email √† l‚Äôobjet utilisateur. Sa valeur est une cha√Æne de caract√®res.

## 7. Supprimer une propri√©t√©
```js
delete utilisateur.age;
```
‚û°Ô∏è Explication :

On supprime la propri√©t√© age de l‚Äôobjet utilisateur. Elle n'existera plus apr√®s cette ligne.

## 8. Propri√©t√©s avec espaces
```js
let utilisateur = {
  "nom complet": "Alice Dupont"
};

console.log(utilisateur["nom complet"]); // "Alice Dupont"
```

‚û°Ô∏è Explication :

Les propri√©t√©s avec des espaces doivent √™tre mises entre guillemets et on ne peut y acc√©der qu‚Äôavec la notation crochets.

## 9. Erreur avec la notation point
```js
console.log(utilisateur.nom complet); // Erreur
```

‚û°Ô∏è Explication :

JavaScript pense ici que tu veux acc√©der √† `utilisateur.nom`, puis faire une op√©ration avec `complet` (comme s‚Äôil manquait un op√©rateur).

Il faut donc utiliser `["nom complet"]` avec des crochets.

## 10. Propri√©t√©s calcul√©es dynamiquement
```js
let fruit = "pomme";
let panier = {
  [fruit]: 5
};

console.log(panier.pomme); // 5
```

‚û°Ô∏è Explication :

La variable `fruit` contient `"pomme"`, donc `[fruit]` devient `pomme`.

L'objet final est en fait : `{ pomme: 5 }`


## 11. Raccourci pour cr√©er des propri√©t√©s
```js
function creerUtilisateur(nom, age) {
  return {
    nom,
    age
  };
}

let utilisateur = creerUtilisateur("Alice", 25);
console.log(utilisateur.nom); // "Alice"
```
‚û°Ô∏è Explication :

Si le nom de la propri√©t√© est le m√™me que la variable, on peut juste √©crire `nom` au lieu de `nom: nom`.

Exemple √©quivalent :
```js
return {
  nom: nom,
  age: age
};
```
## 12. V√©rifier si une propri√©t√© est undefined
```js
if (utilisateur.email === undefined) {
  console.log("La propri√©t√© 'email' n'existe pas.");
}
```

‚û°Ô∏è Explication :

Si utilisateur n‚Äôa pas de propri√©t√© `email`, sa valeur sera `undefined`. On peut le tester comme √ßa.

## 13. V√©rifier avec in
```js
if ("email" in utilisateur) {
  console.log("La propri√©t√© 'email' existe.");
}
```
‚û°Ô∏è Explication :

`"email" in utilisateur` renvoie `true` si l‚Äôobjet poss√®de cette propri√©t√©, m√™me si sa valeur est `undefined`.

## 14. Boucle for...in
```js
for (let cle in utilisateur) {
  console.log(cle + ": " + utilisateur[cle]);
}
```
‚û°Ô∏è Explication :

On parcourt toutes les cl√©s (noms de propri√©t√©s) de l‚Äôobjet. Pour chaque `cle`, on affiche sa valeur avec `utilisateur[cle]`.

## 15. Ordre des propri√©t√©s avec des entiers
```js
let codes = {
  "49": "Allemagne",
  "41": "Suisse",
  "44": "Royaume-Uni",
  "1": "√âtats-Unis"
};

for (let code in codes) {
  console.log(code); // 1, 41, 44, 49
}
```

‚û°Ô∏è Explication :

JavaScript trie les cl√©s num√©riques automatiquement dans l‚Äôordre croissant, m√™me si tu les as √©crites dans un autre ordre.

## 16. Astuce pour garder l'ordre
```js
let codes = {
  "+49": "Allemagne",
  "+41": "Suisse",
  "+44": "Royaume-Uni",
  "+1": "√âtats-Unis"
};

for (let code in codes) {
  console.log(code); // +49, +41, +44, +1
}
```

‚û°Ô∏è Explication :

En mettant un `+` devant les cl√©s, elles ne sont plus consid√©r√©es comme des nombres, donc __l'ordre est conserv√©__ comme tu les as √©crites.

## R√©sum√©

Les objets sont des tableaux associatifs dot√©s de plusieurs fonctionnalit√©s sp√©ciales.

Ils stockent des propri√©t√©s (paires cl√©-valeur), o√π :

    Les cl√©s de propri√©t√© doivent √™tre des cha√Ænes de caract√®res ou des symboles (g√©n√©ralement des cha√Ænes de caract√®res).
    Les valeurs peuvent √™tre de tout type.

Pour acc√©der √† une propri√©t√©, nous pouvons utiliser :

    La notation par points : obj.property.
    Notation entre crochets obj["property"]. Les crochets permettent de prendre la cl√© √† partir d‚Äôune variable, comme obj[varWithKey].

Op√©rateurs suppl√©mentaires :

    Pour supprimer une propri√©t√© : delete obj.prop.
    Pour v√©rifier si une propri√©t√© avec la cl√© donn√©e existe : "key" in obj.
    Pour parcourir un objet : la boucle for (let key in obj).

Ce que nous avons √©tudi√© dans ce chapitre s‚Äôappelle un ‚Äúobjet simple‚Äù (plain object) ou juste Object. Il existe de nombreux autres types d‚Äôobjets en JavaScript :

    Array pour stocker des collections de donn√©es ordonn√©es,
    Date pour stocker des informations sur la date et l‚Äôheure,
    Error pour stocker des informations sur une erreur.
    Etc.

# la diff√©rence entre un objet et une variable

Une __variable__ contient une seule valeur, tandis qu'un __objet__ peut contenir plusieurs valeurs, regroup√©es sous des cl√©s diff√©rentes.
```js
Exemple avec une variable :

let age = 25;  // La variable "age" contient une seule valeur
```
```js
Exemple avec un objet :

let personne = {
  nom: "Alice",
  √¢ge: 30,
  profession: "D√©veloppeur"
};  // L'objet "personne" contient plusieurs valeurs regroup√©es sous des cl√©s
```

L'avantage des objets r√©side dans leur capacit√© √† organiser des donn√©es complexes et √† donner un nom √† chaque morceau de donn√©es (avec des cl√©s).

# Savoir it√©rer dans un objet

Pour acc√©der aux valeurs d'un objet, vous pouvez utiliser deux m√©thodes principales : la notation par point ou la notation par crochets.
```js
    Notation par point :

console.log(voiture.marque);  // "Toyota"
```
```js
    Notation par crochets :

console.log(voiture["mod√®le"]);  // "Corolla"
```

Pour it√©rer √† travers toutes les paires cl√©/valeur, vous pouvez utiliser une boucle `for...in` :
```js
for (let cl√© in voiture) {
  console.log(cl√© + ": " + voiture[cl√©]);
}
// Cela affichera chaque cl√© et sa valeur
```
# Savoir copier un objet (cloner)

En JavaScript, les objets sont __r√©f√©renc√©s__. Cela signifie que si vous assignez un objet √† une autre variable, vous ne cr√©ez pas une copie, mais une r√©f√©rence √† l'objet original.

Exemple :
```js
let original = { nom: "John", √¢ge: 25 };
let copie = original;

copie.nom = "Doe";
console.log(original.nom);  // "Doe"
```

Pour cr√©er une __copie ind√©pendante__ d'un objet, vous pouvez utiliser `Object.assign()` ou l'op√©rateur de d√©composition (...) :

 Avec `Object.assign()` :
```js
let copie = Object.assign({}, original);
```
 Avec l'op√©rateur de d√©composition :
```js
let copie = { ...original };
```
Ces deux m√©thodes permettent de copier uniquement le premier niveau de propri√©t√©s. Pour des objets imbriqu√©s, il existe des techniques plus avanc√©es (par exemple, une fonction de clonage profond).

 # R√©f√©rences et Copies d‚ÄôObjets en JavaScript

## üîπ 1. Les primitives sont copi√©es par valeur

```js
let message = "Hello!";
let phrase = message;
```

- `message` est une **valeur primitive** (string).
- `phrase` re√ßoit **une copie** de la valeur.
- Si on modifie `phrase`, `message` ne change pas.

---

## üîπ 2. Les objets sont copi√©s par r√©f√©rence

```js
let user = { name: "John" };
let admin = user;
```

- `user` contient une **r√©f√©rence** √† l'objet.
- `admin` pointe **vers le m√™me objet**.
- Modifier `admin.name` modifie aussi `user.name`.

---

## üîπ 3. Comparaison par r√©f√©rence


```js
let a = {};
let b = a;
alert(a == b); // true
```

- `a` et `b` pointent vers le **m√™me objet** ‚Üí `true`.

```js
let a = {};
let b = {};
alert(a == b); // false
```

- Deux **objets diff√©rents** ‚Üí `false`.

---

## üîπ 4. Objet const modifiable

```js
const user = { name: "John" };
user.name = "Pete";
```

- On ne peut pas r√©assigner `user`, mais on peut **modifier ses propri√©t√©s**.

---

## üîπ 5. Clonage simple avec une boucle


```js
let user = { name: "John", age: 30 };
let clone = {};

for (let key in user) {
  clone[key] = user[key];
}
```

- Copie manuelle des propri√©t√©s.
- `clone` est **ind√©pendant** de `user`.

---

## üîπ 6. Clonage avec `Object.assign`

```js
let clone = Object.assign({}, user);
```

- Copie automatique des propri√©t√©s.
- Plus rapide et pratique que la boucle.

---

## üîπ 7. Fusion avec `Object.assign`

```js
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

Object.assign(user, permissions1, permissions2);
```

- `user` r√©cup√®re les propri√©t√©s de `permissions1` et `permissions2`.

---

## üîπ 8. Remplacement de propri√©t√©

```js
Object.assign(user, { name: "Pete" });
```

- La propri√©t√© `name` est **remplac√©e**.

---

## üîπ 9. Clonage d‚Äôobjet imbriqu√© (probl√®me)

```js
let user = {
  name: "John",
  sizes: { height: 182, width: 50 }
};

let clone = Object.assign({}, user);
```

- `clone.sizes` et `user.sizes` pointent vers le **m√™me objet**.

---

## üîπ 10. Clonage profond avec `structuredClone`

```js
let clone = structuredClone(user);
```

- Cr√©e une **copie ind√©pendante**, m√™me pour les objets imbriqu√©s.

---

## üîπ 11. R√©f√©rences circulaires avec `structuredClone`

```js
let user = {};
user.me = user;

let clone = structuredClone(user);
```

- `structuredClone` g√®re bien les **r√©f√©rences circulaires**.

---

## üîπ 12. Limites de `structuredClone`

```js
structuredClone({
  f: function() {}
});
```

- ‚ùå **Erreur** : `structuredClone` ne peut pas copier les fonctions.

---

üëâ Utilise `Object.assign` pour les objets simples, et `structuredClone` pour des copies profondes.

# La Ramasse-Miettes (Garbage Collection)

## Introduction
JavaScript g√®re automatiquement la m√©moire. Chaque fois que nous cr√©ons des objets, fonctions ou variables, de la m√©moire est utilis√©e. Quand ces √©l√©ments ne sont plus n√©cessaires, le moteur JavaScript les supprime via un processus appel√© **garbage collection**.

## Le concept d'accessibilit√©
Un objet reste en m√©moire **s‚Äôil est accessible**, c‚Äôest-√†-dire qu‚Äôil peut √™tre atteint depuis un point de d√©part connu.

### Racines (roots)
Les racines sont les points de d√©part :
- Variables globales
- Variables locales des fonctions en cours
- Param√®tres des fonctions en cours

Tout objet accessible depuis une racine par une ou plusieurs r√©f√©rences est conserv√©.

## Exemples

### 1. R√©f√©rence perdue
```js
let user = { name: "John" };
user = null; // L'objet {name: "John"} devient inaccessible => supprim√©
```

### 2. Deux r√©f√©rences
```js
let user = { name: "John" };
let admin = user;
user = null;
// admin r√©f√©rence toujours l'objet => il reste en m√©moire
```

### 3. Objets li√©s
```js
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;
  return { father: man, mother: woman };
}
let family = marry({name: "John"}, {name: "Ann"});
delete family.father;
delete family.mother.husband;
// John devient inaccessible => supprim√©
```

### 4. √éle inaccessible
```js
family = null;
// Tous les objets internes deviennent inaccessibles => supprim√©s
```

## Algorithme mark-and-sweep

1. Le garbage collector marque les **racines**
2. Il suit toutes les r√©f√©rences accessibles depuis les racines
3. Il marque tous les objets atteints
4. Il supprime tout ce qui n‚Äôa pas √©t√© marqu√©

## Optimisations du garbage collector

- **Collecte g√©n√©rationnelle** : objets r√©cents vs anciens
- **Collecte incr√©mentielle** : nettoyage en plusieurs √©tapes
- **Collecte en cas d‚Äôinactivit√©** : ex√©cution quand le processeur est libre

## √Ä retenir

- La m√©moire est g√©r√©e automatiquement.
- Les objets restent en m√©moire tant qu‚Äôils sont accessibles.
- Les r√©f√©rences seules ne garantissent pas l‚Äôaccessibilit√©.


# M√©thodes d'objet et "this" en JavaScript

## Introduction

Les objets repr√©sentent des entit√©s r√©elles :

```js
let user = {
  name: "John",
  age: 30
};
```

Les objets peuvent effectuer des actions via des **m√©thodes** (fonctions stock√©es dans des propri√©t√©s).

## Exemple de m√©thode

```js
let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("Hello!");
};

user.sayHi(); // Hello!
```

Une **fonction dans une propri√©t√©** d‚Äôun objet est une **m√©thode**.
