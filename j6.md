# les Objets 

En JavaScript, un objet est une structure de donnÃ©es permettant de stocker des collections de donnÃ©es et des entitÃ©s plus complexes. Il est composÃ© de paires clÃ©-valeur, oÃ¹ chaque clÃ© (ou propriÃ©tÃ©) est une chaÃ®ne de caractÃ¨res, et chaque valeur peut Ãªtre de n'importe quel type.

Les objets sont omniprÃ©sents en JavaScript et constituent la base de nombreux concepts avancÃ©s.

## 1. CrÃ©ation d'un objet (notation littÃ©rale)
```js
let utilisateur = {
  nom: "Alice",
  age: 25
};
```
â¡ï¸ Explication :

On crÃ©e un objet utilisateur avec deux propriÃ©tÃ©s :

    nom : la valeur est "Alice"

    age : la valeur est 25

C'est une syntaxe classique : `{ clÃ©1: valeur1, clÃ©2: valeur2 }`

## 2. CrÃ©ation avec le constructeur Object
```js
let utilisateur = new Object();
utilisateur.nom = "Alice";
utilisateur.age = 25;
```
â¡ï¸ Explication :

Câ€™est une autre maniÃ¨re de crÃ©er un objet :

 - Dâ€™abord on crÃ©e un objet vide avec `new Object()`

-  Ensuite on ajoute les propriÃ©tÃ©s `nom et age` en les dÃ©finissant avec la notation point.

Câ€™est un peu plus long, mais câ€™est Ã©quivalent au premier exemple.

## 3. AccÃ¨s aux propriÃ©tÃ©s (notation point)
```js
console.log(utilisateur.nom); // "Alice"
```
â¡ï¸ Explication :

On utilise la notation point pour accÃ©der Ã  une propriÃ©tÃ© de lâ€™objet. 

Ici, on affiche "Alice".

## 4. AccÃ¨s aux propriÃ©tÃ©s (notation crochets)
```js
console.log(utilisateur["nom"]); // "Alice"
```
â¡ï¸ Explication :

On accÃ¨de Ã  la mÃªme propriÃ©tÃ© mais avec des crochets et une chaÃ®ne de caractÃ¨res.

Câ€™est utile quand :

- la propriÃ©tÃ© a un espace ou un caractÃ¨re spÃ©cial
- ou quand on utilise une variable comme clÃ© (exemple juste aprÃ¨s)

## 5. AccÃ¨s dynamique avec une variable
```js
let propriete = "age";
console.log(utilisateur[propriete]); // 25
```
â¡ï¸ Explication :

propriete contient "age", donc utilisateur[propriete] revient Ã  faire utilisateur["age"], ce qui donne 25.

## 6. Ajouter une propriÃ©tÃ©
```js
utilisateur.email = "alice@example.com";
```
â¡ï¸ Explication :

On ajoute une nouvelle propriÃ©tÃ© email Ã  lâ€™objet utilisateur. Sa valeur est une chaÃ®ne de caractÃ¨res.

## 7. Supprimer une propriÃ©tÃ©
```js
delete utilisateur.age;
```
â¡ï¸ Explication :

On supprime la propriÃ©tÃ© age de lâ€™objet utilisateur. Elle n'existera plus aprÃ¨s cette ligne.

## 8. PropriÃ©tÃ©s avec espaces
```js
let utilisateur = {
  "nom complet": "Alice Dupont"
};

console.log(utilisateur["nom complet"]); // "Alice Dupont"
```

â¡ï¸ Explication :

Les propriÃ©tÃ©s avec des espaces doivent Ãªtre mises entre guillemets et on ne peut y accÃ©der quâ€™avec la notation crochets.

## 9. Erreur avec la notation point
```js
console.log(utilisateur.nom complet); // Erreur
```

â¡ï¸ Explication :

JavaScript pense ici que tu veux accÃ©der Ã  `utilisateur.nom`, puis faire une opÃ©ration avec `complet` (comme sâ€™il manquait un opÃ©rateur).

Il faut donc utiliser `["nom complet"]` avec des crochets.

## 10. PropriÃ©tÃ©s calculÃ©es dynamiquement
```js
let fruit = "pomme";
let panier = {
  [fruit]: 5
};

console.log(panier.pomme); // 5
```

â¡ï¸ Explication :

La variable `fruit` contient `"pomme"`, donc `[fruit]` devient `pomme`.

L'objet final est en fait : `{ pomme: 5 }`


## 11. Raccourci pour crÃ©er des propriÃ©tÃ©s
```js
function creerUtilisateur(nom, age) {
  return {
    nom,
    age
  };
}

let utilisateur = creerUtilisateur("Alice", 25);
console.log(utilisateur.nom); // "Alice"
```
â¡ï¸ Explication :

Si le nom de la propriÃ©tÃ© est le mÃªme que la variable, on peut juste Ã©crire `nom` au lieu de `nom: nom`.

Exemple Ã©quivalent :
```js
return {
  nom: nom,
  age: age
};
```
## 12. VÃ©rifier si une propriÃ©tÃ© est undefined
```js
if (utilisateur.email === undefined) {
  console.log("La propriÃ©tÃ© 'email' n'existe pas.");
}
```

â¡ï¸ Explication :

Si utilisateur nâ€™a pas de propriÃ©tÃ© `email`, sa valeur sera `undefined`. On peut le tester comme Ã§a.

## 13. VÃ©rifier avec in
```js
if ("email" in utilisateur) {
  console.log("La propriÃ©tÃ© 'email' existe.");
}
```
â¡ï¸ Explication :

`"email" in utilisateur` renvoie `true` si lâ€™objet possÃ¨de cette propriÃ©tÃ©, mÃªme si sa valeur est `undefined`.

## 14. Boucle for...in
```js
for (let cle in utilisateur) {
  console.log(cle + ": " + utilisateur[cle]);
}
```
â¡ï¸ Explication :

On parcourt toutes les clÃ©s (noms de propriÃ©tÃ©s) de lâ€™objet. Pour chaque `cle`, on affiche sa valeur avec `utilisateur[cle]`.

## 15. Ordre des propriÃ©tÃ©s avec des entiers
```js
let codes = {
  "49": "Allemagne",
  "41": "Suisse",
  "44": "Royaume-Uni",
  "1": "Ã‰tats-Unis"
};

for (let code in codes) {
  console.log(code); // 1, 41, 44, 49
}
```

â¡ï¸ Explication :

JavaScript trie les clÃ©s numÃ©riques automatiquement dans lâ€™ordre croissant, mÃªme si tu les as Ã©crites dans un autre ordre.

## 16. Astuce pour garder l'ordre
```js
let codes = {
  "+49": "Allemagne",
  "+41": "Suisse",
  "+44": "Royaume-Uni",
  "+1": "Ã‰tats-Unis"
};

for (let code in codes) {
  console.log(code); // +49, +41, +44, +1
}
```

â¡ï¸ Explication :

En mettant un `+` devant les clÃ©s, elles ne sont plus considÃ©rÃ©es comme des nombres, donc __l'ordre est conservÃ©__ comme tu les as Ã©crites.

## RÃ©sumÃ©

Les objets sont des tableaux associatifs dotÃ©s de plusieurs fonctionnalitÃ©s spÃ©ciales.

Ils stockent des propriÃ©tÃ©s (paires clÃ©-valeur), oÃ¹ :

    Les clÃ©s de propriÃ©tÃ© doivent Ãªtre des chaÃ®nes de caractÃ¨res ou des symboles (gÃ©nÃ©ralement des chaÃ®nes de caractÃ¨res).
    Les valeurs peuvent Ãªtre de tout type.

Pour accÃ©der Ã  une propriÃ©tÃ©, nous pouvons utiliser :

    La notation par points : obj.property.
    Notation entre crochets obj["property"]. Les crochets permettent de prendre la clÃ© Ã  partir dâ€™une variable, comme obj[varWithKey].

OpÃ©rateurs supplÃ©mentaires :

    Pour supprimer une propriÃ©tÃ© : delete obj.prop.
    Pour vÃ©rifier si une propriÃ©tÃ© avec la clÃ© donnÃ©e existe : "key" in obj.
    Pour parcourir un objet : la boucle for (let key in obj).

Ce que nous avons Ã©tudiÃ© dans ce chapitre sâ€™appelle un â€œobjet simpleâ€ (plain object) ou juste Object. Il existe de nombreux autres types dâ€™objets en JavaScript :

    Array pour stocker des collections de donnÃ©es ordonnÃ©es,
    Date pour stocker des informations sur la date et lâ€™heure,
    Error pour stocker des informations sur une erreur.
    Etc.

# la diffÃ©rence entre un objet et une variable

Une __variable__ contient une seule valeur, tandis qu'un __objet__ peut contenir plusieurs valeurs, regroupÃ©es sous des clÃ©s diffÃ©rentes.
```js
Exemple avec une variable :

let age = 25;  // La variable "age" contient une seule valeur
```
```js
Exemple avec un objet :

let personne = {
  nom: "Alice",
  Ã¢ge: 30,
  profession: "DÃ©veloppeur"
};  // L'objet "personne" contient plusieurs valeurs regroupÃ©es sous des clÃ©s
```

L'avantage des objets rÃ©side dans leur capacitÃ© Ã  organiser des donnÃ©es complexes et Ã  donner un nom Ã  chaque morceau de donnÃ©es (avec des clÃ©s).

# Savoir itÃ©rer dans un objet

Pour accÃ©der aux valeurs d'un objet, vous pouvez utiliser deux mÃ©thodes principales : la notation par point ou la notation par crochets.
```js
    Notation par point :

console.log(voiture.marque);  // "Toyota"
```
```js
    Notation par crochets :

console.log(voiture["modÃ¨le"]);  // "Corolla"
```

Pour itÃ©rer Ã  travers toutes les paires clÃ©/valeur, vous pouvez utiliser une boucle `for...in` :
```js
for (let clÃ© in voiture) {
  console.log(clÃ© + ": " + voiture[clÃ©]);
}
// Cela affichera chaque clÃ© et sa valeur
```
# Savoir copier un objet (cloner)

En JavaScript, les objets sont __rÃ©fÃ©rencÃ©s__. Cela signifie que si vous assignez un objet Ã  une autre variable, vous ne crÃ©ez pas une copie, mais une rÃ©fÃ©rence Ã  l'objet original.

Exemple :
```js
let original = { nom: "John", Ã¢ge: 25 };
let copie = original;

copie.nom = "Doe";
console.log(original.nom);  // "Doe"
```

Pour crÃ©er une __copie indÃ©pendante__ d'un objet, vous pouvez utiliser `Object.assign()` ou l'opÃ©rateur de dÃ©composition (...) :

 Avec `Object.assign()` :
```js
let copie = Object.assign({}, original);
```
 Avec l'opÃ©rateur de dÃ©composition :
```js
let copie = { ...original };
```
Ces deux mÃ©thodes permettent de copier uniquement le premier niveau de propriÃ©tÃ©s. Pour des objets imbriquÃ©s, il existe des techniques plus avancÃ©es (par exemple, une fonction de clonage profond).

 # RÃ©fÃ©rences et Copies dâ€™Objets en JavaScript

## ğŸ”¹ 1. Les primitives sont copiÃ©es par valeur

```js
let message = "Hello!";
let phrase = message;
```

- `message` est une **valeur primitive** (string).
- `phrase` reÃ§oit **une copie** de la valeur.
- Si on modifie `phrase`, `message` ne change pas.

---

## ğŸ”¹ 2. Les objets sont copiÃ©s par rÃ©fÃ©rence

```js
let user = { name: "John" };
let admin = user;
```

- `user` contient une **rÃ©fÃ©rence** Ã  l'objet.
- `admin` pointe **vers le mÃªme objet**.
- Modifier `admin.name` modifie aussi `user.name`.

---

## ğŸ”¹ 3. Comparaison par rÃ©fÃ©rence


```js
let a = {};
let b = a;
alert(a == b); // true
```

- `a` et `b` pointent vers le **mÃªme objet** â†’ `true`.

```js
let a = {};
let b = {};
alert(a == b); // false
```

- Deux **objets diffÃ©rents** â†’ `false`.

---

## ğŸ”¹ 4. Objet const modifiable

```js
const user = { name: "John" };
user.name = "Pete";
```

- On ne peut pas rÃ©assigner `user`, mais on peut **modifier ses propriÃ©tÃ©s**.

---

## ğŸ”¹ 5. Clonage simple avec une boucle


```js
let user = { name: "John", age: 30 };
let clone = {};

for (let key in user) {
  clone[key] = user[key];
}
```

- Copie manuelle des propriÃ©tÃ©s.
- `clone` est **indÃ©pendant** de `user`.

---

## ğŸ”¹ 6. Clonage avec `Object.assign`

```js
let clone = Object.assign({}, user);
```

- Copie automatique des propriÃ©tÃ©s.
- Plus rapide et pratique que la boucle.

---

## ğŸ”¹ 7. Fusion avec `Object.assign`

```js
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

Object.assign(user, permissions1, permissions2);
```

- `user` rÃ©cupÃ¨re les propriÃ©tÃ©s de `permissions1` et `permissions2`.

---

## ğŸ”¹ 8. Remplacement de propriÃ©tÃ©

```js
Object.assign(user, { name: "Pete" });
```

- La propriÃ©tÃ© `name` est **remplacÃ©e**.

---

## ğŸ”¹ 9. Clonage dâ€™objet imbriquÃ© (problÃ¨me)

```js
let user = {
  name: "John",
  sizes: { height: 182, width: 50 }
};

let clone = Object.assign({}, user);
```

- `clone.sizes` et `user.sizes` pointent vers le **mÃªme objet**.

---

## ğŸ”¹ 10. Clonage profond avec `structuredClone`

```js
let clone = structuredClone(user);
```

- CrÃ©e une **copie indÃ©pendante**, mÃªme pour les objets imbriquÃ©s.

---

## ğŸ”¹ 11. RÃ©fÃ©rences circulaires avec `structuredClone`

```js
let user = {};
user.me = user;

let clone = structuredClone(user);
```

- `structuredClone` gÃ¨re bien les **rÃ©fÃ©rences circulaires**.

---

## ğŸ”¹ 12. Limites de `structuredClone`

```js
structuredClone({
  f: function() {}
});
```

- âŒ **Erreur** : `structuredClone` ne peut pas copier les fonctions.

---

ğŸ‘‰ Utilise `Object.assign` pour les objets simples, et `structuredClone` pour des copies profondes.

# La Ramasse-Miettes (Garbage Collection)

## Introduction
JavaScript gÃ¨re automatiquement la mÃ©moire. Chaque fois que nous crÃ©ons des objets, fonctions ou variables, de la mÃ©moire est utilisÃ©e. Quand ces Ã©lÃ©ments ne sont plus nÃ©cessaires, le moteur JavaScript les supprime via un processus appelÃ© **garbage collection**.

## Le concept d'accessibilitÃ©
Un objet reste en mÃ©moire **sâ€™il est accessible**, câ€™est-Ã -dire quâ€™il peut Ãªtre atteint depuis un point de dÃ©part connu.

### Racines (roots)
Les racines sont les points de dÃ©part :
- Variables globales
- Variables locales des fonctions en cours
- ParamÃ¨tres des fonctions en cours

Tout objet accessible depuis une racine par une ou plusieurs rÃ©fÃ©rences est conservÃ©.

## Exemples

### 1. RÃ©fÃ©rence perdue
```js
let user = { name: "John" };
user = null; // L'objet {name: "John"} devient inaccessible => supprimÃ©
```

### 2. Deux rÃ©fÃ©rences
```js
let user = { name: "John" };
let admin = user;
user = null;
// admin rÃ©fÃ©rence toujours l'objet => il reste en mÃ©moire
```

### 3. Objets liÃ©s
```js
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;
  return { father: man, mother: woman };
}
let family = marry({name: "John"}, {name: "Ann"});
delete family.father;
delete family.mother.husband;
// John devient inaccessible => supprimÃ©
```

### 4. Ãle inaccessible
```js
family = null;
// Tous les objets internes deviennent inaccessibles => supprimÃ©s
```

## Algorithme mark-and-sweep

1. Le garbage collector marque les **racines**
2. Il suit toutes les rÃ©fÃ©rences accessibles depuis les racines
3. Il marque tous les objets atteints
4. Il supprime tout ce qui nâ€™a pas Ã©tÃ© marquÃ©

## Optimisations du garbage collector

- **Collecte gÃ©nÃ©rationnelle** : objets rÃ©cents vs anciens
- **Collecte incrÃ©mentielle** : nettoyage en plusieurs Ã©tapes
- **Collecte en cas dâ€™inactivitÃ©** : exÃ©cution quand le processeur est libre

## Ã€ retenir

- La mÃ©moire est gÃ©rÃ©e automatiquement.
- Les objets restent en mÃ©moire tant quâ€™ils sont accessibles.
- Les rÃ©fÃ©rences seules ne garantissent pas lâ€™accessibilitÃ©.


# MÃ©thodes d'objet et "this" en JavaScript

## Introduction

Les objets reprÃ©sentent des entitÃ©s rÃ©elles :

```js
let user = {
  name: "John",
  age: 30
};
```

Les objets peuvent effectuer des actions via des **mÃ©thodes** (fonctions stockÃ©es dans des propriÃ©tÃ©s).

## Exemple de mÃ©thode

```js
let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("Hello!");
};

user.sayHi(); // Hello!
```

Une **fonction dans une propriÃ©tÃ©** dâ€™un objet est une **mÃ©thode**.


## Utiliser une fonction existante comme mÃ©thode

```js
function sayHi() {
  alert("Hello!");
}

let user = {};
user.sayHi = sayHi;
user.sayHi(); // Hello!
```

## Programmation orientÃ©e objet (POO)

Utiliser des objets pour structurer le code â†’ POO.  
RÃ©fÃ©rence : *Design Patterns* de Gamma et al., *Object-Oriented Analysis and Design* de Booch.

## Syntaxe abrÃ©gÃ©e pour les mÃ©thodes

```js
let user = {
  sayHi() {
    alert("Hello");
  }
};
```

PrÃ©fÃ©rÃ©e pour sa concision.

## Le mot-clÃ© `this`

`this` rÃ©fÃ©rence **l'objet appelant** la mÃ©thode.

```js
let user = {
  name: "John",
  sayHi() {
    alert(this.name);
  }
};

user.sayHi(); // John
```

## Attention : ne pas utiliser la variable directement

```js
let user = {
  name: "John",
  sayHi() {
    alert(user.name); // pas fiable
  }
};

let admin = user;
user = null;
admin.sayHi(); // Erreur
```

Utilisez `this.name` Ã  la place.

## `this` nâ€™est pas liÃ©

```js
function sayHi() {
  alert(this.name);
}

let user = { name: "John" };
let admin = { name: "Admin" };

user.f = sayHi;
admin.f = sayHi;

user.f(); // John
admin.f(); // Admin
```

## Appel sans objet

```js
function sayHi() {
  alert(this);
}

sayHi(); // undefined en mode strict
```

Sans objet, `this` est `undefined` (mode strict) ou `window` (mode non strict).


## Fonctions flÃ©chÃ©es et `this`

Les fonctions flÃ©chÃ©es n'ont **pas leur propre `this`**.

```js
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

## RÃ©sumÃ©

- Une fonction dans un objet â†’ mÃ©thode.
- Les mÃ©thodes utilisent `this` pour accÃ©der Ã  lâ€™objet.
- `this` est Ã©valuÃ© Ã  l'exÃ©cution.
- Les fonctions flÃ©chÃ©es hÃ©ritent de `this` du contexte parent.

# Comprendre le fonctionnement des tableaux en JavaScript

## ğŸŒ Quâ€™est-ce quâ€™un tableau en JavaScript ?

Un **tableau (array)** est un type d'objet en JavaScript qui permet de **stocker plusieurs valeurs** dans une seule variable.

### ğŸ”¹ DÃ©claration dâ€™un tableau

```javascript
let fruits = ["pomme", "banane", "orange"];
```

- `fruits[0]` â `"pomme"`
- `fruits[1]` â `"banane"`
- `fruits[2]` â `"orange"`

---

## ğŸ“¦ Ajouter, modifier et supprimer des Ã©lÃ©ments

### ğŸ”¹ Ajouter un Ã©lÃ©ment Ã  la fin : `.push()`
```javascript
fruits.push("kiwi");
```

### ğŸ”¹ Ajouter un Ã©lÃ©ment au dÃ©but : `.unshift()`
```javascript
fruits.unshift("fraise");
```

### ğŸ”¹ Supprimer le dernier Ã©lÃ©ment : `.pop()`
```javascript
fruits.pop();
```